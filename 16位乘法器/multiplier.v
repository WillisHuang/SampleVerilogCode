/*--------------------------------------------------------------------
乘法器有兩種:
1.組合邏輯:電路事先將所有乘積項全部計算出來，最後加法運算。

2.時序邏輯:電路將部分已經得到的乘積結果右移，
  然後與乘積項相加並保存和值，反覆迭代上述步驟直到計算出結果
---------------------------------------------------------------------*/

//利用時序邏輯設計16位乘法器
/*--------------------------------------------------------------------
數據吞吐量計算:

數據吞吐量是指晶片在一定時鐘頻率下，所能處理的有效數據量。
晶片完成一次乘法運算需要1個以上的時鐘週期，即使晶片採用300MHz的時鐘頻率，
每秒鐘能處理的有效數據吞吐量也一定小於300M。

對於16位乘法器而言，ain和bin均為0xFFFF時，晶片的運算量最大，
計算所需的時間也最長，這種情況才能作為我們計算數據吞吐量的依據。

ex:
假設晶片在200MHz的條件下ain和bin均為0xFFFF時，需要16個時鐘週期才能得到乘法結果，
那麼晶片在200MHz的條件下，數據吞吐量為:200M/16 = 12.5M

---------------------------------------------------------------------*/

/*--------------------------------------------------------------------
乘法器定義:

 |			 |        |        						  |
 | 信號名稱  |  方向  | 			 描述			  |
 |			 |        |        						  |
 
---------------------------------------------------------------------*/

/*--------------------------------------------------------------------
port 定義:

input clk;     	// 50MHz
input rst_n;	// reset signal , active low
input start;	// 使能信號。 0:信號無效 / 1:讀入乘數和被乘數。
				// 當信號由0 -> 1，會進行一次當前ain 和 bin的乘法運算
				// 進行下一次運算則需要重新拉低該信號後拉高。

input ain;		// 被乘數, 16bits
input bin;		// 乘數, 16bits
output yout;	// 輸出, 32bits
output done;	// 輸出有效標誌位，有效時保持一個時鐘週期高脈衝。
				// 1 : 乘法運算完成; 0 : 運算未完成
--------------------------------------------------------------------*/

module multiplier(
	clk,rst_n,
	start,ain,bin,yout,done
);

input clk;     	// 50MHz
input rst_n;	// reset signal , active low
input start;	// 使能信號。 0:信號無效 / 1:讀入乘數和被乘數。
				// 當信號由0 -> 1，會進行一次當前ain 和 bin的乘法運算
				// 進行下一次運算則需要重新拉低該信號後拉高。

input [15:0] ain;		// 被乘數, 16bits
input [15:0] bin;		// 乘數, 16bits
output [31:0] yout;	// 輸出, 32bits
output done;	// 輸出有效標誌位，有效時保持一個時鐘週期高脈衝。
				// 1 : 乘法運算完成; 0 : 運算未完成
				
reg	[15:0] areg;	//乘數a暫存器
reg	[15:0] breg;	//乘數b暫存器
reg	[31:0] yout_r;	//乘積暫存器
reg done_r;
reg [4:0] i;		//移位次數暫存器

//--------------------------------------------------------------------
//數據位控制
always@(posedge clk or negedge rst_n)
begin
	if(!rst_n) i <= 5'd0;
	else if(start && i < 5'd17) i <= i + 1'b1;
	else if(!start) i <= 5'd0;
end

//--------------------------------------------------------------------
//乘法運算完成標誌信號產生
always@(posedge clk or negedge rst_n)
begin
	if(!rst_n) done_r <= 1'b0;
	else if(i == 5'd16) done_r <= 1'b1;		//乘法運算完成標誌
	else if(i == 5'd17) done_r <= 1'b0;		//標誌位撤銷
end

assign done = done_r;

//--------------------------------------------------------------------
//專用暫存器進行移位累加運算
/*

			21
	x		36
---------------
		   126
	+	   63
---------------
		   756
		   
		   
			1010	10
	x		1101	13
----------------
		    1010
		   0000
		  1010
	+	 1010
----------------
		10000010	130 

		
*/
always@(posedge clk or negedge rst_n)
begin
	if(!rst_n) begin
		areg <= 16'h0000;
		breg <= 16'h0000;
		yout_r <= 32'h00000000;
	end
	else if(start) begin	//啟動運算
		if(i == 5'd0) begin	//鎖存乘數,被乘數
			areg <= ain;
			breg <= bin;
		end
		else if(i > 5'd0 && i < 5'd16) begin	// i = 1, 2, 3, 4, ..., 15, 16
			if(areg[i-1]) yout_r = {1'b0,yout[30:15] + breg, yout_r[14:1]};		//累加並移位
			else yout_r <= yout_r >> 1;		//移位不累加
		end
		else if(i == 5'd16 && areg[15]) yout_r[31:16] <= yout_r[31:16] + breg;	//累加不移位
	end
end

assign yout = yout_r;

endmodule